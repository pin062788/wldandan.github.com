---
layout: post
title: "微服务架构设计与实现(2)"
date: 2015-03-16 22:07
comments: true
categories: MicroService
---

[请勿转载]

# 什么是微服务架构

在上一章中，我们认识了什么是单块架构应用，并分析了随着互联网时代的快速发展，随着市场变化快，用户需求变化快以及用户访问量的增加，单块架构应用的维护成本、人员的培养成本、缺陷修复成本以及技术架构演进的成本和系统扩展成本等都在增加，因此单块架构曾经的优势已逐渐无法适应互联网时代的快速变化，面临着越来越多的挑战。

在本章中，我们来了解到底什么是微服务架构，以及为什么微服务架构能有效解决单块架构在互联网时代所面临的挑战。

### 概述

   微服务架构一词在过去几年里，得到了广泛的讨论和关注。微服务架构提倡通过对特定业务领域的分析与建模，将复杂的、
集中的、耦合度高的应用系统分解成小而专、耦合度低并且高度自治的一组服务。这些服务与服务之间相互协作、相互配合，从而为最终用户或其他系统提供相应的功能。微服务将每个独立的业务逻辑划分出来，运行在它们自己的进程中，然后通过分布式的网络互相通信与协作，从而为终端用户或其他调用者提供灵活的接口。

<!-- More -->

   与传统IT行业的'服务架构'概念不一样的是，微服务更强调的是一种独立测试、独立部署、独立运行的软件架构模式。微服
务中的每个服务，都可以作为一个独立的业务单元进行测试、部署，而且每个服务都能独立运行在不同的进程中。这些微服务满足细粒度的业务需求，并使用自动化部署工具进行发布。同时，这些微服务可以使用不同的开发语言，不同框架，以及不同的数据存储技术，因此相比与'服务架构'，它是一种高度自治的、非集中式管理的、细粒度的业务单元。

   实际上，微服务架构并不是一个全新的概念。早在二十几年前，面向服务架构（SOA）概念的提出，就已经阐述了类似的思
想，“对于复杂的企业IT系统，应按照不同的、可重用的粒度划分，将功能相关的一组提供者组织在一起为消费者提供服务”。
仔细分析SOA的概念，就会发现，其在服务的定义上和我们今天所谈到的微服务定义大致类似，那为什么在SOA的概念提出这么多年后，又诞生了这个貌似是新瓶装旧酒的微服务架构呢？其实，鉴于过去十几年互联网行业的高速发展，以及敏捷、持续集成、持续交付、DevOPS，云技术等的深入人心，服务架构的开发、测试、部署以及监控等，相比我们提到的传统的SOA，已经大相径庭。相比SOA，微服务要更具有独立性、灵活性、可实施性以及可扩展性。换句话说，微服务架构是一种更接地气的面向服务架构，是一种更容易帮助企业或组织构建演进式架构的方法和实践。关于更多SOA与微服务的区别，请参考[X部分]。


### 微服务架构的定义

   其实，即便了解了上面的介绍，还是很难对微服务下一个准确的定义。就像NoSQL，我们谈论了好几年的NoSQL，知道NoSQ
L代表着什么样的含义，也可以根据不同的应用场景选择不同的NoSQL数据库，但是我们还是很难对它下一个准确的定义。类似的，关于‘什么是函数式编程’，也或多或少存在同样的窘境。我们可以轻松的选择不同的函数式编程语言，可以轻松的写出函数式编程风格的代码，但很难对什么是函数式编程下一个准确的定义。
   
   微服务本身并没有一个严格的定义。不过从业界的讨论来看，微服务通常具有“小独轻松”这四个特点：

#### 1. 小，且专注于做一件事情
	
   微服务架构通过对特定业务领域的分析与建模，将复杂的应用分解成小而专一、耦合度低并且高度自治的一组服务。那么微服
务中提倡的‘微’或者‘小’，到底是多‘微’、多‘小’才合适呢？

  每个服务都是很小的应用，至于有多小，是一个非常有趣的话题。有人觉得用代码行数来作为‘微’的衡量标准比较合适，譬如说，有人喜欢100行以内，有人
赞成1000行以内。其实，大家都很明白，对于不同的语言，完成同样功能的代码行数也完全不一样，因此数字显然无法成为衡量微服务是否够‘微’的决定因素。

  另外，有些人认为，既然是微服务，就应该简单。譬如说，就应该在2周内，能够非常容易的重写，这样才符合小和微的概念。实际上，2周时间，对不同的个体而言
，结果可能大相径庭。我们知道，这种情况很大部分取决于个体的工作经验、对业务背景的了解以及对相关技术的熟悉程度等等。譬如说，工作年限长的开发者通常情况下可能对其擅长的技术更熟练，而对业务熟悉程度较好的开发者，如果重写完成的更快。因此，多长时间能够重写微服务也不能作为衡量其是否小的因素。

  其实，我个人认为，微服务的“微”并不是一个真正可衡量、看得见、摸得着的“微”。这个“微”所表达的，是一种设计思想和指导方针，是需要团队或者组织共同努力
找到的一个平衡点。因此，微服务到底有多微，是个仁者见仁，智者见智的问题，最重要的是团队觉得合适就好。但注意，当考虑微服务的“微”时，至少应该遵循两个原则：业务独立性和团队自主性。首先，应该保证微服务是具有业务独立性的单元，在这个前提下，由团队来判断当前的服务大小是否合适，考虑到团队的沟通成本，一般不建议超过10个人的团队，或者在超过10个人的团队中，可以再划分子团队。在这种情况下，当团队中大部分成员认为当前的服务是能够容易维护的、容易理解的，这就是我们认为适合团队的、有意义的“微”。

   专注于做一件事情。从我们接触编程的第一天起，老师就教授我们，写出来的代码要符合“高内聚、低耦合”的原则，作为曾经似懂非懂的学生而言，我们也一直在朝
着这个方向努力着；另外，在面向对象设计的领域中，有几条放之四海而皆准的重要原则，那就是“SOLID原则”。大家请注意，在SOLID原则中的的第一条，叫单一职责原则（SRP-Single responsibility principle），其实描述的也是类似的事情。具体点说，单一职责原则的核心思想是：一个类，应该只有一个职责，也只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把多个不同的职责耦合在了一起。这种耦合会导致当其中的某一职责发生变化时，可能会导致原本运行正常的其他职责或者功能发生故障。另外职责过多，也会导致引起该类变化的原因增多，多个职责之间相互依赖，容易产生影响，从而极大的损伤其内聚性和耦合度。Unix/Linux便是这一原则的完美体现者：在Unix中，各个程序都独立负责一个单一的事，我们可以通过管道将它们容易的连接起来。而Windows，则是这一原则的典型的反面示例：Windows中几乎所有的程序代码都交织耦合在一起，并没有做到一个类，只关注一个职责并把它做好。因此，如果希望避免这种现象的发生，就要尽可能的遵守单一职责原则，增强应用程序或者代码的内聚性以及降低耦合性。

#### 2. 运行在独立的进程中
  
   微服务是一个具有高度自治性的独立业务实体，通常情况下，每个服务都能够运行在一个独立的操作系统进程中，这也意味
着不同的服务能非常容易的被部署到不同的主机上。之前我们提到过，在传统的单块架构应用中，我们通常将逻辑功能的代码分成三层，并定义一些公共的共享库，但最终分布在三层的功能代码，以及依赖的公共组件，都会被打入一个发布包，部署后运行在同一个进程中。
  注意，这里所说的组件，指的是可以独立升级、独立替换掉的这一部分。在传统的单块架构中，组件通常的形态叫共享库，譬如jar包、Dll等，它们都是组件的一种形态。但在微服务的架构里，组件是一个服务，他们运行在不同的进程中，由多个服务组件共同协作，完成一个应用程序，因此这种方式和传统的是不太一样的。




理论上，虽然我们能够将多个服务部署到同一台节点上，但并不推荐这么做。作为微服务，我们希望它能够保持高度的自治性和隔离性。即使将不同的服务部署在不同的节点上会增加一部分开销，但相比分布式系统的管理、维护所带来的开销和成本，前者要低得多的。




   
  服务和服务之间通过轻量级的通信机制，实现彼此间的互通互联，互相协作。所谓轻量级通信机制，通常指基于语言无关、平
台无关、代码无关的这类标准协议，例如我们熟悉的XML，或者目前比较流行的JSON，它们都属于轻量级的通信机制。对于传统我们熟知的Java RMI或者.Net Remoting等，虽然这类协议能够使应用程序像调用本地API一样调用远程的接口，但其最大的劣势在于，这类协议和语言、平台有强耦合性，因此缺乏灵活性和扩展性。对于微服务而言，通过使用语言无关、平台无关的轻量级通信协议，能够让微服务在实现上更关注内部的细节。
  	
  不需要改变依赖，只更改当前服务本身，就可以独立部署。这意味着该服务和其他服务之间在部署和运行上呈现相互独立的状
态。

综上所述，微服务架构采用多个服务间互相协作的方式构建应用。每个服务独立运行在不同的进程中，服务与服务之间通过轻量的通讯机制交互，并且每个服务可以通过自动化部署方式独立部署。
