---
layout: post
title: "微服务架构设计与实现(2)"
date: 2015-03-16 22:07
comments: true
categories: MicroService
---

[请勿转载]

#什么是微服务架构

在上一章中，我们认识了什么是单块应用架构，并分析了随着业务的不断扩大，需求的持续增加，单块架构所表现出的各种水土不服，那么接下来，我们来看看什么是微服务架构，以及为什么微服务架构能有效解决单块架构在业务需求快速增加，代码量快速增加情况下所遇到的问题的。

###微服务架构

   微服务架构一词在过去几年里，得到了广泛的讨论和关注。微服务架构提倡通过对特定业务领域的分析与建模，将复杂的、
集中的、耦合度高的应用系统分解成小而专、耦合度低并且高度自治的一组服务，由这些服务与服务之间相互协作、相互配合，从而为最终用户或其他系统提供相应的功能。微服务将每个独立的业务逻辑划分出来，运行在它们自己的进程中，换句话说，每个服务都能按需运行在一个独立的物理节点中，然后通过分布式的网络互相通信与协作，从而为终端用户或其他系统提供相应的完整功能。

<!-- More -->

   与传统IT行业的'服务架构'概念不一样的是，微服务更强调的是一种独立测试、独立部署、独立运行的软件架构模式。微服
务中的每个服务，都可以作为一个独立的业务单元进行测试、部署，而且每个服务都能独立运行在不同的进程中。这些微服务满足细粒度的业务需求，并使用自动化部署工具进行发布。同时，这些微服务可以使用不同的开发语言，不同框架，以及不同的数据存储技术，因此相比与'服务架构'，它是一种高度自治的非集中式管理的细粒度业务单元。

   实际上，微服务架构并不是一个全新的概念。早在二十几年前，面向服务架构（SOA）概念的提出，就已经阐述了类似的思
想，“对于复杂的企业IT系统，应按照不同的、可重用的粒度划分，将功能相关的一组提供者组织在一起为消费者提供服务”。
仔细分析SOA的概念，就会发现，其在服务的定义上和我们今天所谈到的微服务定义大致类似，那为什么在SOA的概念提出这么多年后，又诞生了这个貌似是新瓶装旧酒的微服务架构呢？其实，鉴于过去十几年互联网行业的高速发展，以及敏捷、持续集成、持续交付、DevOPS，云技术等的深入人心，服务架构的开发、测试、部署以及监控等，相比我们提到的传统的SOA，已经大相径庭。相比SOA，微服务要更具有独立性、灵活性、可实施性以及可扩展性。换句话说，微服务架构是一种更接地气的面向服务架构，是一种更容易帮助企业或组织构建演进式架构的方法和实践。关于更多SOA与微服务的区别，请参考[X部分]。


###微服务架构的定义

   看到这里，好像是明白了。真的是明白了吗？

   其实，即便了解了上面的介绍，还是很难对微服务下一个准确的定义。就像NoSQL，我们谈论了好几年的NoSQL，知道NoSQ
L代表着什么样的含义，也可以根据不同的应用场景选择不同的NoSQL数据库，但是我们还是很难对它下一个准确的定义。类似的，关于‘什么是函数式编程’，也或多或少存在同样的窘境。我们可以轻松的选择不同的函数式编程语言，可以轻松的写出函数式编程风格的代码，但很难对什么是函数式编程下一个准确的定义。
   
   微服务本身并没有一个严格的定义。不过从业界的讨论来看，微服务通常有如下几个特点:

1. 小，且专注于做一件事情
	
   微服务架构通过对特定业务领域的分析与建模，将复杂的应用分解成小而专、耦合度低并且高度自治的一组服务。那么微服
务中提到的小，是多'小'才合适呢？

   每个服务都是很小的应用，至于有多小，是一个非常有趣的话题。有人喜欢100行以内，有人赞成1000行以内，语言不一
样，完成同样功能的代码行数也不一样，因此数字并不是衡量微服务是否小的最重要因素。另外，有些人认为，既然是微服务，就应该在2周内能够容易的被重写，这样才符合小和微的概念。但我们知道，这种情况很大部分取决于个体的工作经验、背景以及对业务的熟悉程度等，譬如说，工作年限长的开发者通常情况下可能对其擅长的技术更熟练，而对业务熟悉程度较好的开发者也会重现的更快。因此，多长时间能够重写微服务也不能作为衡量其是否小的因素。所以，到底应该多小，其实是仁者见仁，智者见智的问题，但至少决定这个小时，应该遵循两个原则：业务独立性和团队自主性。首先，应该保证微服务是具有业务独立性的单元，在这个前提下，由团队来判断当前的服务大小是否合适，考虑到团队的沟通成本，一般不建议超过10个人的团队，或者在超过10个人的团队中，可以再划分子团队。在这种情况下，当团队中大部分成员认为当前的服务是能够容易维护的、容易理解的，这就是我们认为合适的小。

   专注于做一件事情。从我们接触编程的第一天起，老师就教授我们，写出来的代码要符合“高内聚、低耦合”。另外，在面向
对象设计的领域中，有几条放之四海而皆准的重要原则SOLID原则，而SOLID中的的第一条，描述的就是单一职责原则（SRP-Single responsibility principle）。单一职责原则的核心思想是：一个类，应该只有一个职责，也只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把多个不同的职责耦合在了一起。这种耦合会导致当其中的某一职责发生变化时，可能会导致原本运行正常的其他职责或者功能发生故障。另外职责过多，也会导致引起该类变化的原因增多，多个职责之间相互依赖，容易产生影响，从而极大的损伤其内聚性和耦合度。Unix/Linux是这一原则的完美体现者，各个程序都独立负责一个单一的事。而Windows则是这一原则的反面示例，几乎所有的程序都交织耦合在一起。因此，如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则，增强内聚性和降低耦合性。
对象设计的领域中，有几条放之四海而皆准的重要原则SOLID原则，而SOLID中的的第一条，描述的就是单一职责原则（SRP-Single responsibility principle）。单一职责原则的核心思想是：一个类，应该只有一个职责，也只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把多个不同的职责耦合在了一起。这种耦合会导致当其中的某一职责发生变化时，可能会导致原本运行正常的其他职责或者功能发生故障。另外职责过多，也会导致引起该类变化的原因增多，多个职责之间相互依赖，容易产生影响，从而极大的损伤其内聚性和耦合度。Unix/Linux是这一原则的完美体现者，各个程序都独立负责一个单一的事。而Windows则是这一原则的反面示例，几乎所有的程序都交织耦合在一起。因此，如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则，增强内聚性和降低耦合性。

2. 高度自治性
  
   微服务是一个具有高度自治性的独立业务实体，通常情况下，每个服务都能够运行在一个独立的操作系统进程中，这也意味
着不同的服务能被部署到不同的主机上。理论上，虽然我们能够将多个服务部署到同一台节点上，但并不推荐这么做。作为微服务，我们希望它能够保持高度的自治性和隔离性。即使将不同的服务部署在不同的节点上会增加一部分开销，但相比分布式系统的管理、维护所带来的开销和成本，前者要低得多的。
   
  服务和服务之间通过轻量级的通信机制，实现彼此间的互通互联，互相协作。所谓轻量级通信机制，通常指基于语言无关、平
台无关、代码无关的这类标准协议，例如我们熟悉的XML，或者目前比较流行的JSON，它们都属于轻量级的通信机制。对于传统我们熟知的Java RMI或者.Net Remoting等，虽然这类协议能够使应用程序像调用本地API一样调用远程的接口，但其最大的劣势在于，这类协议和语言、平台有强耦合性，因此缺乏灵活性和扩展性。对于微服务而言，通过使用语言无关、平台无关的轻量级通信协议，能够让微服务在实现上更关注内部的细节。
  	
  不需要改变依赖，只更改当前服务本身，就可以独立部署。这意味着该服务和其他服务之间在部署和运行上呈现相互独立的状
态。

综上所述，微服务架构采用多个服务间互相协作的方式构建应用。每个服务独立运行在不同的进程中，服务与服务之间通过轻量的通讯机制交互，并且每个服务可以通过自动化部署方式独立部署。
