I---
layout: post
title: "微服务架构设计与实现(1) - 架构模式的发展与单块架构存在的弊端"
date: 2015-03-16 22:07
comments: true
categories: MicroService
---

### 概述

多年来，我们一直在技术的浪潮中乘风破浪，扬帆奋进，寻找更优秀的方法来构建IT系统，也一直在积极的学习并观察先进的公司如何以不同的架构方式构建或者优化其IT系统，来积极应对市场的变化，迅速做出响应，从而为客户提供更多的价值。

微服务架构模式(Microservice Architect Pattern)是近两年在软件架构模式领域里出现的一个新名词。虽然其诞生的时间不长，但其在各种演讲、文章、书籍上所出现的频率已经让很多人意识到它对软件领域所带来的影响。那到底什么是微服务，当我们谈论微服务时，它代表着一种什么样的含义？微服务适合应用在什么场景下，以及它有什么样的优缺点？

###架构模式发展简史

为了更好的理解微服务架构，让我们先来回顾一下WEB开发架构模式的发展历程。

曾经，当我们开发Web系统的时候，最简单的实现方案就是用HTML实现几个静态页面，然后相互之间配置好跳转的链接，放在服务器上，就可以为用户提供信息了。随后，由于要处理用户的数据，如添加、删除、显示等，于是系统需要使用数据库、文件或者其他一些存储介质来存储数据，为了区别Client/Server模式的应用，我们亲切的称之为Browser/Server系统。随着信息化行业的快速发展以及B/S系统天生的易部署、易升级性，B/S系统的应用也愈加广泛，市场也有了更多的需求，譬如电子商务平台，以及传统的办公自动化平台或者各种企业信息化管理平台都在从C/S转向B/S。

以电子商务平台为例，其功能在业务发展的过程中也逐步完善，譬如有了用户验证、有了购物车，支持了评论、在线支付、货到付款等。但大部分的时候，所有的业务逻辑都交织在一起，错综复杂，为了使系统有个良好的架构并降低维护成本，架构师以及开发者们通过使用面向对象分析、设计模式、企业架构模式等方式将不同的业务模块进行划分，同时引入分层的方式将不同职责的部分放在不同的层，于是，经典的三层架构出现了。

#####三层架构

   三层架构是一种架构模式，它是从应用架构的角度对应用程序进行分层，通常包括数据访问层，业务逻辑层以及表示层。数
据访问层主要关注对原始数据（数据库或者文本文件等存放数据的形式）的操作。也就是说，它关注的是应用程序是如何有效的将数据存储到数据库、文件系统或者其他存储介质中。有一点要注意的是，它关心的是对原始数据的操作，而非原始数据的存储介质本身。譬如，在电子商务平台中，商品的信息是如何存储及获取的，图片的信息是如何存储以及获取的等；业务逻辑层则主要聚焦应用程序对业务问题的逻辑处理，以及业务流程的操作。譬如，在电子商务平台中，当用户购买商品后，应用程序如何对订单进行处理，如何决定订单的折扣、配送方式等；表示层则主要负责为用户提供用户接口部分（UI），譬如如何帮助用户使用系统，如何接受用户的请求，如何为用户提供数据展示等。目前的用户接口大部分情况下为WEB方式，当然也可以是传统桌面软件的形式，例如.NET的WINFORM或者Java的SWING，以及其他客户端的方式。

   三层架构的出现，一方面是为了解决应用程序中代码间调用复杂、代码职责不清的问题。其通过在各层间定义接口，并将接
口与实现分离，可以很容易的用不同的实现来替换原有层次的实现，从而有效降低层与层之间的依赖。这种方式不仅有利于帮助团队理解整个应用架构，降低后期维护成本，同时也有利于制定整个应用程序架构的标准。另一方面，三层结构的出现从某种程度上也解决了企业内部如何有效的根据技能调配人员，提高生产效率的问题。在大环境下，有效的分层能使不同职责的人员各司其职，更聚焦与个人专业技能的发展和培养。三层结构的出现不仅标准化了复杂系统的逻辑划分，更帮助企业解决了如何有效形成技术人员组织结构的问题，因此在很长的一段时间里，它一直是软件架构的经典模式之一。

#####单块架构应用

   前面提到过，三层架构并不是物理上的三层，而是应用架构的逻辑上的三层。这也就意味着即便我们将应用架构分成了三
层，但分层的代码最终在物理上还是会被部署并运行在同一个服务器节点中。也就是说，所有的代码在经历过编译、打包、部署后，最终还是都运行在同一个机器的同一个进程中。对于这种功能集中、代码库中心化、部署后运行在同一进程的应用程序，我们通常称之为单块架构应用。

   纵向扩展

   水平扩展

   随着最近十年互联网行业的迅猛发展，随着公司或者组织业务的不断扩张，应用程序面临了新一轮的挑战。譬如，如何为
用户提供更可靠的服务，如何处理用户增多后导致并发请求数增多的问题，以及如何解决用户增多后带来的大数据量的问题。这些问题的出现，使得部署在单节点上的应用已经没法满足日益增长的需求，因此越来越多的单块架构应用面临着如何进行有效的水平扩展(Scale Out)。当我们考虑对应用程序水平扩展时，通常的做法是建立一个集群，通过在集群中不断的添加新节点，然后借助前端的负载均衡器，将用户的请求按照某种算法，譬如轮转法、散列法或者最小连接法等合理的将请求分配到不同的节点上。当然，如果某些节点保持状态，如用户登陆后的Session等，则增加了水平扩展的难度。

##### 单块架构应用的弊端

	随着业务的不断扩大，需求不断的增加，越来越多的人加入开发团队，同时代码库也在急剧膨胀。在这种情况
下，代码的可维护性、扩展性、灵活性在降低，而测试成本、构建成本以及维护成本却在显著增加。因此，随着项目或者产品规模的继续扩大，单块架构应用开始呈现越来越多的问题。

	维护成本增加

   随着应用程序的功能越来越多，团队越来越大，代码也变得越来越复杂，难以维护。譬如说，对于使用Java编写的中型应用
而言，当代码量为几十万行时，可能只需要10人左右的团队，缺陷的平均修复周期一般在2周左右。当代码量上升到百万行级别时，可能需要接近百人左右的团队，随着人员增多的同时，沟通成本也显著增加，提交代码、编译过程、构建打包、自动化测试等过程所花费的时间都会显著增高；另外，对于分析缺陷、定位缺陷、修复缺陷的成本都会相应增高。因此，这时候缺陷的平均修复周期可能变成2个月。另外，随着代码量的增大，在开发人员对全局功能缺乏深度理解的情况下，修复完一个缺陷，还有可能引入其他缺陷，在自动化测试机制不完善的情况下，很可能导致缺陷修复的过程陷入“越修越多”的恶性循环。

	新人培养周期长

   随着应用程序的功能越来越多，代码变得越来越复杂的同时，对于新加入团队的成员而言，了解行业背景、熟悉应用程序业
务、配置本地开发环境，这些看似简单的任务，将会花费更长的时间。我曾经有个朋友，在加入一家世界500强的知名IT公司后，被安排到了一个百万级代码的产品组里。他花了将近1个月的时间来熟悉产品文档、配置开发环境后，才在本地成功的运行起了这个应用。在他换工作后的头一个月里，我问他好几次工作进展，得到的答案都是一样，“看文档，装环境”。对个人而言，花一个月时间来配置本地开发环境，其中的滋味和感受大家可想而知，我估计人世间比这更痛苦的事情也没几件了；而对公司或者部门而言，本期望员工花费数天就能配置好的环境，却花了一个月才能完成，这更是极大的浪费。更有甚者，在第一次配置完开发环境后，好几年都不愿意再升级或者重装系统，真是一招被蛇咬，十年怕井绳。

	
   对集成开发环境要求高
	
   代码库越庞大，依赖越多，对开发环境的性能要求就越高。十年前，当我刚工作时，编写Java代码所使用的笔记本，一般配
置都是2G内存，当时使用Eclipse加载一个中等类型的应用（大概10万行代码量的样子），觉得就挺吃力，于是一直希望公司给我升级内存。但现在，虽然笔记本的内存在不断升级，已增加到16G或者更高，但貌似大型的应用系统也越来越多，其对环境的依赖也越来越复杂。尤其是现在有些复杂的业务系统，通常不仅需要安装数据库，WEB容器、还需要安装中间件服务器、消息队列等。因此，随着应用系统的代码库愈发庞大，功能越多，集成开发环境在加载、编译整个应用程序代码的过程中，耗时也变得越来越长。


   应用程序扩展困难

   此外，因为所有程序代码都运行在服务器上的相同进程中，导致应用程序的扩展非常困难。如果应用程序某部分的功能是内
存密集型的，譬如需要缓存大量数据，而另外一部分功能是CPU密集型的，譬如需要进行大量的运算，那么运行该应用的服务器必须有足够的内存和强劲的CPU来满足该应用系统的需求。因此，鉴于每个服务器都要提供该应用系统所需要的各种资源，基础设施的整体花费可能会非常高。


   对团队结构的影响

   最后，非常微妙的是，随着应用程序的功能越来越多，代码变得越来越复杂，其分层的结构组成也会逐渐映射到研发团队的
结构上。例如，用户体验工程师（UX）更专注负责用户接口部分，业务层开发者则负责建立服务器后端的业务逻辑，数据库工程师和DBA们更关注数据访问组件和数据库。鉴于这些问题，随着时间的推移，不仅代码越来越难以管理，其对团队结构的影响也越来越明显。

------------------------------------------------------------

###什么是微服务架构

微服务架构概念的提出就是来解决这些问题的。微服务将每个独立的业务逻辑划分出来，运行在它们自己的进程中，也就说，每个服务都能按需运行在独立的节点中，通过分布式的网络通信，完成一个应用的完整功能。

微服务架构提倡通过对特定业务领域的分析与建模，将复杂的应用分解成小而专、耦合度低并且高度自治的一组服务，由这些服务与服务之间相互协作、相互配合，从而为最终用户或其他系统提供相应的功能。与传统IT行业的'服务'概念不一样的是，每个服务独立运行在不同的进程中，服务之间通过轻量的通讯机制交互，并且每个服务都可以作为独立的业务单元进行测试、部署。

实际上，微服务架构并不是一个全新的概念。早在十几年前，面向服务架构（SOA）概念的提出，就已经提出了类似的思想：对于复杂的企业IT系统，应按照不同的、可重用的粒度划分，将功能相关的一组提供者组织在一起为消费者提供服务。仔细分析SOA的概念，就会发现，其在服务的定义上和我们今天所谈到的微服务定义大致类似，那为什么在SOA的概念提出这么多年后，又诞生了这个新瓶装旧酒的微服务呢？实际上，鉴于过去十年互联网行业的快速发展，以及敏捷、持续集成、持续交付、DevOPS，云技术等的深入人心，服务架构的开发、测试、部署以及监控等，相比我们提到的传统的SOA，已经大大不同。相比SOA，微服务要更具有可实施性、易实施性以及扩展性。换句话说，微服务架构是更接地气的一种面向服务架构，是一种更容易帮助企业构建一套持续改进的软件架构方法。关于更多SOA与微服务的区别，请参考[X部分]。


听起来好像明白了？但这些还是很难帮助我们对微服务下一个明确的定义，就像NoSQL，我们谈论了好几年的NoSQL，我们知道NoSQL是什么，我们可以根据不同的应用场景选择不同的NoSQL数据库，但是我们很难对它下一个明确的定义。类似的，关于什么是’函数式编程’，我们可以轻松的选择不同的函数式编程语言，但很难对什么是函数式编程下一个明确的定义。

所以，我们与其讨论其定义，不如看看它的核心特征是什么。那么什么是核心特征，就是当我们谈论同一件事情的时候，什么是不同的人们所讨论的相同的部分。

虽然微服务架构本身并没有一个严格的定义。不过从业界的讨论来看，微服务通常有如下几个显著特征:

1. 小，且专注于做一件事情
	
   之前提到，微服务架构通过对特定业务领域的分析与建模，将复杂的应用分解成小而专、耦合度低并且高度自治的一组服务，由这些服务与服务之间相互协作、相互配合，从而为最终用户或其他系统提供相应的功能。

   多'小'才合适

   每个服务都是很小的应用，至于有多小，是一个非常有趣的话题。有人喜欢100行以内，有人赞成1000行以内，语言不一样，完成同样功能的代码行数也不一样，因此数字并不是衡量微服务是否小的最重要因素。另外，有些人认为，微服务应该在2周内能够容易的重写，这样才符合小的概念。但我们知道，这种情况很大部分取决于个体的工作经验、背景以及对业务的熟悉程度等，譬如说，工作年限长的开发者通常情况下可能对其擅长的技术更熟练，而对业务熟悉程度较好的开发者也会重现的更快。因此，多长时间能够重写微服务也不能作为衡量其是否小的因素。所以，到底应该多小，其实是仁者见仁，智者见智的问题，但至少决定这个小时，应该遵循两个原则：业务独立性和团队自主性。首先，应该保证微服务是具有业务独立性的单元，在这个前提下，由团队来判断当前的服务大小是否合适，考虑到团队的沟通成本，一般不建议超过10个人的团队，或者在超过10个人的团队中，可以再划分子团队。在这种情况下，当团队中大部分成员认为当前的服务是能够容易维护的、并且容易理解的，同时再做持续集成或者自动化测试时候的等待时间不超过10分钟。这就是我们认为比较合适的小。

   专注于做一件事情。从我们接触编程的第一天起，老师就教授我们，写出来的代码要符合“高内聚、低耦合”。另外，面向对象设计的SOLID原则，第一条也告诉我们，设计的对象应该符合“单一职责原则”。关于单一职责原则，其核心的思想是：一个类，只做一件事，并把这件事做好，其只有一个引起它变化的原因。单一职责原则可以看作是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而极大的损伤其内聚性和耦合度。单一职责，通常意味着单一的功能，因此不要为一个模块实现过多的功能点，以保证实体只有一个引起它变化的原因。Unix/Linux是这一原则的完美体现者。各个程序都独立负责一个单一的事。而Windows是这一原则的反面示例。几乎所有的程序都交织耦合在一起。


2. 轻量级的通信机制
 	在传统的单块架构应用中，考虑到实现的简便性，应用程序和应用程序之间通常都会使用远程调用的方法来互相通信。
例如，我们熟知的Java RMI或者.Net Remoting等，这些都是与语言、平台密切相关的通信协议。这类协议的好处在于，能够在应用内部像使用本地API一样使用远程的调用。但其最大的劣势在于失去了灵活性。譬如，选择了Java的RMI，就意味着系统只能使用Java作为开发语言。
对于微服务之间的通信，则是采用轻量级的、语言无关的机制实现彼此间的通信，例如JSON、XML等。通过使用这类语言无关的通信协议，能够让微服务在实现上更关注内部的细节，选取最合适的技术实现业务。


3. 松耦合
	不需要改变依赖，只更改当前服务本身，就可以独立部署。这意味着该服务和其他服务之间在部署和运行上呈现相互独立的状态。

综上所述，微服务架构采用多个服务间互相协作的方式构建应用。每个服务独立运行在不同的进程中，服务与服务之间通过轻量的通讯机制交互，并且每个服务可以通过自动化部署方式独立部署。


###微服务架构的特征

我们不能说是微服务建筑风格的正式定义，但我们可以尝试描述我们所看到的共同特性适合标签的架构。由于与概括的共同特点，并不是所有的微服务架构拥有所有的特点，但我们预计，大部分微服务架构展示最具特色的任何定义。而我们的作者一直这个社区相当松散的积极成员，我们的目的是试图和我们在我们自己的工作看到了我们所知道的团队同样努力的说明。特别是，我们没有放下一些定义，以符合。

我们没有办法对微服务风格进行准确的定义，但是我们可以偿试着描述一下微服务风格所应该具有的觉特性，这样就可以对它打上相应的标签了。正如其它定义中对特性的描述一新，并不是所有的微服务风格都要所有的特性，但是我们认为常见的微服务都应该有这些特性。尽管我们是相当松散的社区核心成员，但是我们也计划偿试描述我们工作中或者在其它我们了解的组件中所理解的微服务。当然，我们并不依赖于那些已经明确过的定义。

组件与服务
	
	自从我们从事软件行业以来，一直希望能够构建灵活的即插即用的组件系统，就像大部分情况，我们所看到的现实世界的物体，能够自由组合并协同工作一样。在过去的几十年里，我们已经看到了大部分语言平台的公共库的进行了精简，并取得可观的进展。

	当我们谈论组件的时候，有可能会纠结组件到底代表着什么。为了避免歧义，我们申明，这里的组件是指软件中独立的单元，它是能够被独立的替代和更新的。

    微服务架构也使用组件库，但是它更主要的是把软件拆分成小的服务。我们把组件库定义为程序中相互关系、并使用内存中调用的组件，把服务定义为进程间使用如Web服务请求或者远程调用来相互通信的组件。（和面向对象程序中定义的Service对象不太一样）

    把服务当成组件（而不是库）的一个主要的原因是服务可以独立的部署。如果你的应用由多个库组成并跑在一个进程中，那么任何库的变更都将导致整体应用的重新发布。但是如果应用程序由多个服务构成，我们可以想像，每个服务的变更仅需要重新部署相应的服务。当然，这也不是绝对的，比如某些对服务接口的变更就需要其相关服务也发生变化，但微服务架构的目的，设计是尽量避免这种服务间的耦合并完善服务的交互接口。

    把服务当成组件的另一个考虑是这将拥有更新清晰的接口。许多开发语言并没有良好的定义公共接口的机制。通常只有文档和规范说明，让用户避免组件间会导致组件耦合的过度的依赖。不过服务由是是通过明确的远程接口调用，这个问题就很容易解决了。
    使用服务也有它的不足之处。远程调用比进制内部调用更消耗性能，而且远程的API比较粗糙，难以使用。如果由于对组件的职责进行变更，影响到跨进程间的交互，那么这操作起来也比较困难。
    第一个可能的特性，我们看到每个服务是运行在独立的进程上的。注意，这只是第一个可能的特性。服务也可以由多个进程组成，它们是同时开发和部署的，例如服务可能用到一个应用进制和一种数据禀。


###使用微服务架构的优势

###为什么说微服务的诞生不是偶然

###微服务与SOA





如上所述，每个微服务都对应了一个独立的业务功能，也只定义了该功能所必须的一些操作。这听起来比较类似面向服务架构（SOA），事实上，微服务架构和面向服务的架构确实有很多共同的特性。两个架构都使用服务的模式组织代码，两种架构在不同的服务间都建立了非常明确的边界。然而，面向服务的架构起源于Monolithic应用程序交互的需求，通常彼此都会提供一个API（基于SOAP）。在面向服务架构中，集成重度依赖于中间件，特别在企业服务总线（EBS）中。微服务架构通常会利用一个消息总线，但是无论任何情况在消息层都不会存在逻辑——它纯粹的被用于服务之间的交互。这与ESB有着非常显著的差别，ESB包含了大量逻辑——用于消息路由、模式验证、消息翻译和业务规则。因此，对比传统的面向服务架构，微服务架构往往更为简单，不会包含用于定义服务间接口的同级别控制和规范化数据建模。通过使用微服务，开发将非常快速，服务的衍变也只需匹配业务的需求。

然而，不容忽视的是，微服务同样存在一些劣势。因为服务通常部署在多个主机上，很难持续跟踪指定服务究竟运行在某台主机上。同时，因为微服务架构使用的主机容量往往小于Monolithic架构，随着微服务架构不停的横向扩展，主机数量将以一个非常恐怖的速度增长。在AWS环境中，微服务架构中独立服务需要的资源往往会小于最小的EC2实例类型。从而造成了超量配置并浪费开销。此外，如果服务使用不同的编程语言将开发，这就意味着每个服务的部署都需要完全不同的库和框架，从而服务的部署非常复杂。


微服务架构的另一个核心优势就是服务可以基于资源的需求进行独立扩展。取代运行包含大量CPU和内存的大服务器，微服务可以被部署在更小的主机上，这些主机只需要满足其部署服务的需求。同时，开发者可以根据业务的需求选择开发语言，比如：一个图像处理服务可以使用类似C++这样的高性能语言实现，一个执行数学或者静态操作的服务可以使用Python实现，对资源进行增删查改的基础操作则往往通过Ruby进行。在微服务中，开发者并不需要考虑Monolithic架构中使用的“一刀切”模型——比如只使用MVC框架和单一的编程语言。




很多人谈到Unix命令行，当我们想得到某个目录下的所有按照时间排序的文件名，我们通常会用管道结合多个进程来运行它们。

如果考虑水平扩展性，对于单块架构程序，我们通常是把它们分别放在不同的机器上，但每个机器上运行的应用程序都是一样的。但对于微服务而言，它则提供了更多的灵活性，提倡每个节点运行在不同的机器上，并且有些节点可能是类似的应用程序，有些不是。

如果考虑水平扩展性，对于单块架构程序，我们通常是把它们分别放在不同的机器上，但每个机器上运行的应用程序都是一样的。但对于微服务而言，它则提供了更多的灵活性，提倡每个节点运行在不同的机器上，并且有些节点可能是类似的应用程序，有些不是。


虽然微服务架构并不是一个全新的概念，但它的诞生也绝非偶然: 

	* 埃里克·埃文斯的《领域驱动设计》使我们明白通过代码诠释现实世界中领域问题的重要性，并指导我们如何用更好的方法分析、设计并模型化真实世界中复杂的业务；
	* 敏捷方法论以及其实践，例如极限编程或者Scrum等，提醒着我们要高效、灵活，拥抱变化，并帮助我们消除浪费，建立快速、持续反馈的机制；
	* 持续交付告诉我们构建稳定、可靠的部署流水线对产品交付的重要性，并强调产品价值应该是以小批量、频繁、快速的方式提供给用户；
	* 虚拟化技术、云环境的使用则帮助我们大幅度简化物理环境的创建、安装、配置。
	* 基础设施自动化( Infrastructure As Code)为我们提供了一键部署的功能，同时简化了应用安装、配置的繁琐步骤，并使得水平扩容机制更加容易实现；
	* DevOps文化的流行，以及全功能团队的出现等等，使得小团队的协作与运行更加自组织化并且高效。 

等等。当然，还有更多的因素我们无法一一列出。


   从上面的因素我们可以看出，无论是从领域设计，还是方法论、工程实践，团队文化等，整个IT行业都在朝着更有效，更能响应市场变化，以及为用户带来更多价值的方向发展。
所以说，微服务概念的提出并不是一个偶然，它是软件架构设计随着IT行业的快速发展，适应市场需求快速变化而发展出的一个产物。

