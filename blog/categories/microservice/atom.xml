<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: MicroService | Happy Coding, Happy Life]]></title>
  <link href="http://wldandan.github.com/blog/categories/microservice/atom.xml" rel="self"/>
  <link href="http://wldandan.github.com/"/>
  <updated>2016-10-09T19:50:26+08:00</updated>
  <id>http://wldandan.github.com/</id>
  <author>
    <name><![CDATA[wldandan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[解析微服务架构]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/17/microservice-design-and-implementation/"/>
    <updated>2015-03-17T11:13:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/17/microservice-design-and-implementation</id>
    <content type="html"><![CDATA[<p>过去的1年多，一直在助力澳洲最大的房地产互联网门户，研究并使用微服务架构改造其复杂的遗留系统。鉴于此，准备开个系列，讲讲我个人眼中的微服务是神马样的，它的概念，优缺点，为什么我们要使用它，以及在使用微服务的实践过程中，从开发、测试、部署、运维等几个方面相比以前方式有什么不同；同时，分享一下我们在微服务实践过程中的经验和踩过的那些坑。</p>

<p>目录大概如下</p>

<ul>
<li><h3>理论篇</h3>

<ul>
<li><h5>单块架构应用以及挑战</h5></li>
<li><h5>什么是微服务</h5></li>
<li><h5>微服务的核心特征</h5></li>
<li><h5>微服务的优缺点</h5></li>
<li><h5>微服务的适用场景</h5></li>
<li><h5>微服务与SOA</h5></li>
<li><h5>微服务诞生的催化剂</h5></li>
</ul>
</li>
<li><h3>实践篇</h3>

<ul>
<li><h5>麻雀虽小，五脏俱全</h5></li>
<li><h5>实现一个服务</h5></li>
<li><h5>微服务开发模板的重要性</h5></li>
<li><h5>不仅仅是REST</h5></li>
<li><h5>消费者驱动的契约测试</h5></li>
<li><h5>如何划分微服务</h5></li>
<li><h5>微服务的依赖管理</h5></li>
<li><h5>微服务与DevOPS</h5></li>
<li><h5>微服务与监控</h5></li>
</ul>
</li>
<li><h3>案例篇</h3>

<ul>
<li><h5>合同管理系统</h5></li>
<li><h5>市场定价系统</h5></li>
<li><h5>信息搜索系统</h5></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构（四）]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-4-wei-fu-wu-jia-gou-de-you-que-dian/"/>
    <updated>2015-03-16T22:07:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-4-wei-fu-wu-jia-gou-de-you-que-dian</id>
    <content type="html"><![CDATA[<p>[请勿转载]</p>

<h1>微服务架构的优缺点</h1>

<p>将单块架构应用分解为一系列相对独立的微服务，其中每个服务都运行在自己的进程中，并且通过轻量级的机制实现彼此间的通信，这通常是HTTP资源的微服务。这些服务是围绕着业务功能构建的，并且可以通过完全自动化的部署机制进行独立部署。这些服务的集中式管理做到了最小化，每一种服务都可以通过不同的编程语言进行编写，并且可以使用不同的数据存储技术。</p>

<!-- More -->


<p>从上面的定义可以看出，微服务的优势是显而易见的：</p>

<ul>
<li>每个服务都很简单，只关注于一个业务功能。</li>
<li>每个微服务可以由不同的团队独立开发。</li>
<li>微服务是松散耦合的。</li>
<li>微服务可以通过不同的编程语言与工具进行开发。</li>
</ul>


<p>这些优势使得微服务看起来是非常完美的解决方案，不过微服务难道就没有缺点么？下面我们就来探讨一下微服务在其实施过程中所遇到的问题和一些缺点。</p>

<h5>运维成本过高</h5>

<h5>DevOps是必须的</h5>

<h5>接口不匹配</h5>

<h5>代码重复</h5>

<h5>分布式系统的复杂性</h5>

<p>总而言之，微服务架构有很多吸引人的地方，不过在拥抱微服务之前，你需要认清它所带来的挑战。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构（三）]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-3-wei-fu-wu-jia-gou-de-he-xin-te-zhen/"/>
    <updated>2015-03-16T22:07:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-3-wei-fu-wu-jia-gou-de-he-xin-te-zhen</id>
    <content type="html"><![CDATA[<p>[请勿转载]</p>

<h1>微服务架构的核心特征</h1>

<p>   什么是核心特征，就是当我们谈论同一件事情的时候，那些不同的人们所关注的相同的部分。从业界的讨论来看，微服务通
常有如下几个显著特征:</p>

<ul>
<li><h5>服务与组件</h5></li>
</ul>


<p>  一直以来，我们都比较提倡使用组件（Component）的方式，模块化应用系统。它类似生活中的汽车，由不同的零件组成，每个零件都是可以独立替换的。因此，这类通常都有很好的灵活性和替换性。</p>

<p>  在软件领域，我们也将组件定义为应用软件构建中独立的单元，它的最大特点是，对整个应用软件而言，组件能够被容易的替代或者更新。</p>

<p>   传统实现组件的方式是采用和应用程序一样的的编程语言，构建独立的共享库（Libaray），从而达到解耦和复用的效果。对于共享库而言，我们知道它是语言相关、平台相关，并且是和应用程序运行在同一个进程中的，因此，任何共享库的变化都意味着整个应用程序也要被更新，并且需要被重新部署。换句话说，如果应用由多个共享库组件组成，那么任何库的变更都将导致整体应用的重新发布。</p>

<!-- More -->


<p>   其实，微服务也可以作为组件。把微服务当成应用程序中的组件，其中一个最主要的好处是微
服务可以独立部署。如果应用由多个共享库组成，那么其只能跑在一个进程中，那么任何库的变更都将导致整体应用的重新发布。</p>

<p><img src="/images/microservice-design-and-practice/chapter3/library-as-component-800-600.png" /></p>

<p>但是如果应用程序由多个服务构成，我们可以想像，大部分情况下，每个服务的变更仅需要重新部署相应的服务。当然，这也不是绝对的，比如某些对服务接口的变更就需要其相关服务也发生变化，但微服务架构的目的，是尽量避免这种服务间的耦合并完善服务的交互接口。换句话说，通过服务来实现组件，将应用拆散为一系列的服务，运行在不同的进程中时，任何一个服务的局部变化只需重新部署对应的服务本身。同时，将服务作为组件也可以帮助我们明确的定义出组件的边界，因为服务之间的调用是跨进程的，清晰的边界和职责定义应该是在设计阶段时必须考虑的。</p>

<p><img src="/images/microservice-design-and-practice/chapter3/service-as-component-800-600.png" /></p>

<p>   把服务当成组件的另外一个优点是在组件和组件之间、或者组件和应用程序之间定义了清晰的、跨语言、跨平台的接口。许
多开发语言虽然定义了良好的公共调用接口的机制，也提供了详尽的文档和规范说明，但由于共享库其本身的特性，充分依赖于特定平台、特定语言，因此组件间的耦合度较高。同共享库相比，微服务是通过语言无关、平台无关的远程接口调用，因此不存在这个问题。当然，使用微服务也有它的不足之处，那就是远程调用比进制内部调用更消耗性能，而且远程的接口由于是分布式调用，无疑增加了维护的复杂度。</p>

<ul>
<li><h5>围绕业务组织团队</h5></li>
</ul>


<p>  在单块应用架构的时代，为了节省成本、快速实现目标，企业或者组织一般都会根
据技能类型的差异化来划分团队。例如用户体验设计师一般都被划分到用户体验设计团队，而懂服务器端的开发人员，一般都被归类为后端业务逻辑开发团队；对于那些精通数据库技能的开发者，一般会在DBA团队中找到他们的身影。实际上，当团队被按照这个策略或者维度划分后，即便是某些简单的需求变更，都有可能导致不同团队之间跨组织、跨团队的协作，耗费很高的跨团队的沟通和协作成本。</p>

<p>  正如<a href="http://en.wikipedia.org/wiki/Conway's_law">康威定律（Conway’s law)</a>提出的，一个组织的设计成果，其
结构往往对应于这个组织中的沟通和组织结构。另外，《敏捷宣言》的一个核心理念是“个体与交互高于过程和工具”。</p>

<p>如果仔细想想，我们发现康威定律从正反两方面支持了这一理念。有些公司受困于垂直、等级化的管理结构，这给工程师们带来了完成工作时不必要的阻力。更多的互联网公司则放手，让团队找到自组织的管理结构。我们既看到“漠视”康威定律所造成的危害，也看到了“拥抱”该定律所带来的好处。</p>

<p><img src="/images/microservice-design-and-practice/chapter3/build-team-aroud-business-800-600.png" /></p>

<p>   而微服务架构的开发模式不同于传统方式，它倡导围绕应用程序为核心，按业务能力来划分为不同的团队。每个团队都要求能
够对每个服务，将其对应的业务领域的全部功能实现，譬如对于某业务需求的更改，从用户体验界面到业务逻辑实现，再到数据的存储和迁移等。因此团队的组织是跨职能的，会包含实现该业务所需功能的所有技能。近年兴起的全栈工程师正是因为架构和开发模式的转变而出现，当然具备全栈的工程师其实很少，但将不同领域的工程师组织为一个全栈的团队就容易的多。</p>

<ul>
<li><h5>关注产品而不是项目</h5></li>
</ul>


<p>   传统的应用开发大部分都是基于项目模式的。什么是项目模式？就是当项目启动后，企业或者组织会从开发
团队中抽出一部分资源、从测试团队中抽出一部分资源，同时也从其他不同的技能团队中抽出不同的资源，组成一个项目团队，然后设置一个时间期限，让大家完成项目。当项目结束后，所有的资源都会被释放，所有人在项目中的职责结束。</p>

<p><img src="/images/microservice-design-and-practice/chapter3/team-by-skills-800-600.png" /></p>

<p>   但服务架构倡导的是避免采用这种项目模式，更倾向于让开发团队负责整个产品的生命周期。大家熟知的亚
马逊CTO Werner Vogels，曾经说过一句经典的名言，“You build it, you run it”。即对于开发产品的团队而言，产品就是团队的，也是每个成员的。团队中的每个人都有责任、有义务确保产品的快速发展以及演进。</p>

<ul>
<li><h5>去中心化</h5></li>
</ul>


<p>   在第二章我们提到，传统的单块应用架构，倾向于采用统一的技术平台或方案来解决所有问题。其实，我们
知道，在现实生活中，并不是每个问题都是钉子，也不是每个解决方案都是一个锤子。
问题有其具体性，解决方案也应有其针对性。用最适合的技术方案去解决具体的问题，往往会事半功倍。传统的单块架构系统倾向采用统一的技术平台或方案来解决所有问题，而微服务的架构意味着，可以针对不同的业务特征选择不同的技术方案，有针对性的解决具体的业务问题。</p>

<p>   对于单块架构系统，初始的技术选型严重限制将来采用不同语言或框架的能力。如果想尝试新的编程语言
或者框架，没有完备的功能测试集，很难平滑的完成替换，而且系统规模越大，风险越高。</p>

<p>  而基于微服务架构，使我们更容易在系统上尝试新的技术或解决方案。譬如说，可以先挑选风险最小的服务作为尝试，快速得到
反馈后再决定是否试用于其他服务。这也意味着，即便对一项新技术的尝试失败，也可以抛弃这个方案，并不会对整个产品带来风险。</p>

<ul>
<li><h5>独立业务数据</h5></li>
</ul>


<p>  传统的单块应用架构，倾向于采用统一的数据存储平台来存储所有的数据。随着业务的快速发展，需求的不断变化，一方面，数
据变得越来越复杂，难以管理；另一方面，随着应用系统的业务逻辑不断更新和发展，数据库不仅承担着数据存储的作用，还承担着不同系统之间的集成作用。同时，传统的数据库大多是关系型数据库，存储的数据都是以结构化信息为主，但随着互联网的快速发展，数据的结构并不具有确定性，或者说结构发生变化的频率非常快，因此，对于如何有效维护业务数据，也成了一个难题，相应的维护成本越来越高。</p>

<p>  微服务架构，提倡具有业务属性的独立单元或者服务自身维护其相关的业务数据。这样的话，有几个非常明显的优势：首先具有
业务属性的服务单元能够有权利管理其相关的数据，同时能够随着业务的发展，不断更新业务数据。其次，每个业务单元只关心自己的业务数据，因此可以选择最合适的工具或者产品来存储以及管理数据。譬如可以根据具体业务场景，使用MySQL、PostgreSQL等关系型数据库，也可以使用文档类型的MongoDB、键值类型的Riak等NoSQL数据库。譬如，在一个复杂的电商系统中，产品数据的种类繁多，更新也比较频繁，如果使用类似MongoDB这种文档数据库，能灵活的根据需求动态调整结构。而像当用户访问系统时产生的会话信息，则可以使用Redis等键值系统进行存储；通常来说，报表数据的结构变化不大，而且要求数据的高一致性，因此可以使用熟悉的关系型数据库。</p>

<p><img src="/images/microservice-design-and-practice/chapter3/polyglot-persistence-800-600.png" /></p>

<ul>
<li><h5>基础设施自动化</h5></li>
</ul>


<p>随着云技术的大规模推广与使用，部署和运维的复杂度在大幅度降低。利用云，我们可以快速的创建系统需要的资源，降低应用的交付周期。同时，由于持续集成、持续交付等实践的深入人心，很多团队都开始在构建软件的过程中，使用持续交付提倡的基础设施自动化技术（更多关于持续交付的知识，请参考《持续交付-发布可靠软件的系统方法》一书）。</p>

<p>这也就意味着，如果微服务架构将应用程序本身分成多个小的服务，每个服务都是一个独立的部署单元。因此，微服务的实践，对持续交付和部署流
水线要求非常高。微服务的粒度越细，就意味着需要部署的业务单元就越多，业务单元越多，就需要更稳定的基础设置自动化机制，能够创建运行环境，安装依赖，部署应用等。</p>

<p><img src="/images/microservice-design-and-practice/chapter2/loose-decouple-microservice-800-600.png" /></p>

<ul>
<li><h5>演进式架构设计</h5></li>
</ul>


<p>  在过去十年中，敏捷方法论以及其实践已经被越来越多的组织尝试并认可。敏捷方法论正在帮助组织以拥抱变化的心
态，去不断尝试，不断获取反馈，从而以高效的方式构建正确的应用系统。实际上，敏捷并不是一种静止的状态，它是组织一直在拥抱变化，尝试改变、获取反馈的演进式发展的一个动态过程。</p>

<p>  类似的，架构设计也应该是随着业务的发展而不断发展，随着需求的变化而不断变化的。当我们试图构建一个单块应用架构系统
时，我们会面临非常艰难的技术选型。哪种方案才是合理的？那种方案才是最正确的？在传统的单块设计中，企业或者组织通常是希望构建一个大而全、无所不能的平台，但是在技术发展如此之快的今天，单一的技术平台已经无法适应市场的快速变化，组织应该随着业务的发展，随着企业的发展，不断尝试并改进架构设计，真正做到业务驱动架构，架构服务于业务。</p>

<hr />

<h3>总结</h3>

<p>微服务强调的是一种独立测试、独立部署、独立运行的软件架构模式，是一种更灵活、更开放、更松散的演进式架构。通过本章所介绍的微服务的核心特征，帮助我们更清晰、深刻的理解了微服务其概念背后所蕴含的思想。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构(二)]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-2-shen-me-shi-wei-fu-wu-jia-gou/"/>
    <updated>2015-03-16T22:07:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-2-shen-me-shi-wei-fu-wu-jia-gou</id>
    <content type="html"><![CDATA[<p>[请勿转载]</p>

<h1>什么是微服务架构</h1>

<p>在上一章中，我们认识了什么是单块架构应用，并分析了随着互联网时代的快速发展，随着市场变化快，用户需求变化快以及用户访问量的增加，单块架构应用的维护成本、人员的培养成本、缺陷修复成本以及技术架构演进的成本和系统扩展成本等都在增加，因此单块架构曾经的优势已逐渐无法适应互联网时代的快速变化，面临着越来越多的挑战。</p>

<p>在本章中，我们来了解到底什么是微服务架构，以及为什么微服务架构能有效解决单块架构在互联网时代所面临的挑战。</p>

<h3>概述</h3>

<p>   微服务架构一词在过去几年里，得到了广泛的讨论和关注。微服务架构提倡通过对特定业务领域的分析与建模，将复杂的、
集中的、耦合度高的应用系统分解成小而专、耦合度低并且高度自治的一组服务。这些服务与服务之间相互协作、相互配合，从而为最终用户或其他系统提供相应的功能。微服务将每个独立的业务逻辑划分出来，运行在它们自己的进程中，然后通过分布式的网络互相通信与协作，从而为终端用户或其他调用者提供灵活的接口。</p>

<!-- More -->


<p>   与传统IT行业的'服务架构'概念不一样的是，微服务更强调的是一种独立测试、独立部署、独立运行的软件架构模式。微服
务中的每个服务，都可以作为一个独立的业务单元进行测试、部署，而且每个服务都能独立运行在不同的进程中。这些微服务满足细粒度的业务需求，并使用自动化部署工具进行发布。同时，这些微服务可以使用不同的开发语言，不同框架，以及不同的数据存储技术，因此相比与'服务架构'，它是一种高度自治的、非集中式管理的、细粒度的业务单元。</p>

<p>   实际上，微服务架构并不是一个全新的概念。早在二十几年前，面向服务架构（SOA）概念的提出，就已经阐述了类似的思
想，“对于复杂的企业IT系统，应按照不同的、可重用的粒度划分，将功能相关的一组提供者组织在一起为消费者提供服务”。
仔细分析SOA的概念，就会发现，其在服务的定义上和我们今天所谈到的微服务定义大致类似，那为什么在SOA的概念提出这么多年后，又诞生了这个貌似是新瓶装旧酒的微服务架构呢？其实，鉴于过去十几年互联网行业的高速发展，以及敏捷、持续集成、持续交付、DevOPS，云技术等的深入人心，服务架构的开发、测试、部署以及监控等，相比我们提到的传统的SOA，已经大相径庭。相比SOA，微服务要更具有独立性、灵活性、可实施性以及可扩展性。换句话说，微服务架构可以被认为是一种更接地气的面向服务架构，是一种更容易帮助企业或组织构建演进式架构的方法和实践。关于更多SOA与微服务的区别，请参考[X部分]。</p>

<h3>微服务架构的定义</h3>

<p>   其实，即便了解了上面的介绍，还是很难对微服务下一个准确的定义。就像NoSQL，我们谈论了好几年的NoSQL，知道NoSQ
L代表着什么样的含义，也可以根据不同的应用场景选择不同的NoSQL数据库，但是我们还是很难对它下一个准确的定义。类似的，关于什么是‘函数式编程’，也或多或少存在同样的窘境。我们可以轻松的选择不同的函数式编程语言，可以轻松的写出函数式编程风格的代码，但很难对什么是函数式编程下一个准确的定义。</p>

<p>   实际上，从业界的讨论来看, 微服务本身并没有一个严格的定义。不过，ThoughtWorks的首席科学家，马丁-
福勒先生对微服务的这段描述，似乎更加具体、贴切，通俗易懂：</p>

<blockquote><p>  The microservice architectural style is an approach to developing a single application as a
suite of small services, each running in its own process and communicating with lightweight
mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</p></blockquote>

<p>  微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值
。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP协议的RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p>

<p>  如果我们仔细分析这段话，不难发现，对于微服务的定义，我们可以从以下几个方面考虑：</p>

<h4>小，且专注于做一件事情</h4>

<p>   微服务架构通过对特定业务领域的分析与建模，将复杂的应用分解成小而专一、耦合度低并且高度自治的一组服务。每个服务都
是很小的应用。那么，微服务中提到的‘微’或者‘小’，到底是多‘微’、多‘小’呢？</p>

<p><img src="/images/microservice-design-and-practice/chapter2/confuse-how-small-800-600.png" /></p>

<p>实际上，关于多小的服务才合适，是一个非常有趣的话题。有人觉得使用代码行数来作为‘微’的衡量标准比较合适，而有些人认为，既然是微服务，就应该简单。就应该在很短的时间内，譬如2周内，能够非常容易的重写该服务，这样才符合小和微的概念。</p>

<p>关于代码行数，我们知道，不同的语言有不同的特点。静态类型语言的主要优点在于其结构非常规范，存在编译期的语法检查、便于调试，类型安全性高，通常其继承关系简洁明了，IDE对其支持也更加友好；但缺点是为此需要写更多的类型相关代码。因此如果实现同样的功能，代码量相对稍多，这类语言的典型代表有Java、C#等；动态语言，其灵活性较高，运行时可以改变内存的结构，无类型检查，不需要写非常多的类型相关的代码；缺点自然就是不方便调试，命名不规范时会造成不易理解等，典型的代表如JavaScript、Ruby或者Python等。另外，还有一些数学类计算语言，能够使用非常简洁的公式实现其逻辑。</p>

<p>譬如说，对于经典的<a href="http://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F">康威生命游戏</a>而言，游戏开始时，细胞随机的被指定为存活或者死亡状态（黑色表示存活，白色表示死亡），每个细胞都会不断的演进，并且在演进的过程中，每个细胞下一代的状态由该细胞当前周围8个细胞的状态所决定，</p>

<p>其具体的规则如下图所示：</p>

<ul>
<li><p>规则1，如果一个细胞周围有少于2个存活细胞，则该细胞无论存活或者死亡，下一代将死亡；</p></li>
<li><p>规则2，如果一个细胞周围有多于3个存活细胞，则该细胞无论存活或者死亡，下一代将死亡；</p></li>
<li><p>规则3，如果一个细胞周围有3个存活细胞，则该细胞下一代将存活；</p></li>
<li><p>规则4，如果一个细胞周围且仅有2个存活细胞，则该细胞下一代状态保持不变；</p></li>
</ul>


<p><img src="/images/microservice-design-and-practice/chapter2/conwey-problem-description-800-600.png" /></p>

<p>对于这个问题，各位如果感兴趣的话，可以尝试使用自己最擅长的语言来试试。</p>

<p>但这里，我想说的是，有一种语言叫APL（<a href="http://en.wikipedia.org/wiki/APL_(programming_language)">A Programing Language</a>），如果我们使用它来实现，需要如下一行代码就可以解决该问题。</p>

<p>```
life←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}</p>

<p>```</p>

<p>因此，对于实现同样的功能，选择不同的语言，代码的行数会有千差万别。因此代码行数这种量化的数字显然无法成为衡量微服务是否够‘微’的决定因素。</p>

<p>另外，有些人认为，既然是微服务，就应该简单。譬如说，就应该在固定时间内（譬如2周），能够非常容易的重写，这样才符合微的概念。实际上，2周时间，对不同的个体而言 ，其服务重写的结果可能大相径庭。我们知道，对于重写这种情况，很大部分取决于个体的工作经验、擅长的语言、对业务背景的了解等等。譬如说，工作年限长的开发者通常情况下可能对其擅长的技术更熟练，而对业务熟悉程度较好的开发者，如果重写可能完成的更快。因此，多长时间能够重写该服务也不能作为衡量其是否小的重要因素。</p>

<p>因此，我个人认为，微服务的“微”并不是一个真正可衡量、看得见、摸得着的“微”。这个“微”所表达的，是一种设计思想和指导方针，是需要团队或者组织共同努力找到的一个平衡点。因此，微服务到底有多微，是个仁者见仁，智者见智的问题，最重要的是团队觉得合适就好。但注意，当考虑微服务的“微”时，至少应该遵循两个原则：业务独立性和团队自主性。首先，应该保证微服务是具有业务独立性的单元，在这个前提下，由团队来判断当前的服务大小是否合适，考虑到团队的沟通成本，一般不建议超过10个人，或者在超过10个人的团队中，可以再划分子团队。在这种情况下，当团队中大部分成员认为当前的服务是能够容易维护的、容易理解的，这就是我们认为适合团队的、有意义的“微”。</p>

<p>   专注于做一件事情。从我们接触编程的第一天起，老师就教授我们，写出来的代码要符合“高内聚、低耦合”的原则，作为曾经似懂非懂的学生而言，我们也一直在朝
着这个方向努力着；另外，在面向对象设计的领域中，有几条放之四海而皆准的重要原则，那就是“SOLID原则”。大家请注意，在SOLID原则中的的第一条，叫单一职责原则（SRP-Single responsibility principle），其实描述的也是类似的事情。具体点说，单一职责原则的核心思想是：一个类，应该只有一个职责，也只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把多个不同的职责耦合在了一起。这种耦合会导致当其中的某一职责发生变化时，可能会导致原本运行正常的其他职责或者功能发生故障。另外职责过多，也会导致引起该类变化的原因增多，多个职责之间相互依赖，容易产生影响，从而极大的损伤其内聚性和耦合度。Unix/Linux便是这一原则的完美体现者：在Unix中，各个程序都独立负责一个单一的事，我们可以通过管道将它们容易的连接起来。而Windows，则是这一原则的典型的反面示例：Windows中几乎所有的程序代码都交织耦合在一起，并没有做到一个类，只关注一个职责并把它做好。因此，如果希望避免这种现象的发生，就要尽可能的遵守单一职责原则，增强应用程序或者代码的内聚性以及降低耦合性。</p>

<h4>运行在独立的进程中</h4>

<p>  在传统的单块架构应用中，我们通常将应用程序的代码分成逻辑上的三层、四层甚至更多层，但它并不是物理上的分层。这也
就意味着，经过开发团队对不同层的代码实现，经历过编译（如果非静态语言，可以跳过编译阶段）、打包、部署后，不考虑负载均衡以及水平扩展的情况，应用程序会运行在同一个机器的同一个进程中。</p>

<p>另外，为了提高代码的重用率以及可维护性，在应用开发中，我们有时也会将重复的代码提取出来，封装成组件。注意，这里所说的组件，指的是可以独立升级、独立替换掉的这一部分。在传统的单块架构中，组件通常的形态叫共享库，譬如JVM平台下的jar包、或者Windows下的DLL等，它们都是组件的一种形态。当应用程序在运行期时，所有的组件最终也会被加载到同一个进程中运行。如下图所示：</p>

<p><img src="/images/microservice-design-and-practice/chapter2/run-in-one-process-800-600.png" /></p>

<p>但在微服务的架构里，应用程序有多个服务组成，每个服务都是一个具有高度自治性的独立业务实体，通常情况下，每个服务都能够运行在一个独立的操作系统进程中，这就意味着不同的服务能非常容易的被部署到不同的主机上。</p>

<p><img src="/images/microservice-design-and-practice/chapter2/run-in-multiple-process-800-600.png" /></p>

<p>理论上，虽然我们能够将多个服务部署到同一台节点上，并让它们运行在不同的进程中，这种方式是可行的，但并不推荐这么做。作为微服务运行的环境，我们希望它能够保持高度的自治性和隔离性。如果多个服务运行在同一个服务器节点上，虽然省去了节点的开销，但是增加了部署和伸缩的复杂度。譬如，当部署某个新的服务时，如果当前节点正在运行的多个进程的多个服务，则必然会对这些服务造成影响。另一方面，如果运行在某个阶段的多个服务中，某些服务随着业务的发展需要伸缩，某些服务却不需要，如何有效的组织这些服务？会给服务的水平伸缩带来不必要的麻烦。</p>

<h4>轻量级的通信机制</h4>

<p>  服务和服务之间通过轻量级的通信机制，实现彼此间的互通互联，互相协作。所谓轻量级通信机制，通常指基于语言无关、平
台无关、代码无关的这类协议，例如我们熟悉的XML或者JSON，他们的解析和使用与语言无关、平台无关。另外，基于HTTP协议，能让服务间的通信变得无状态化，目前大家所熟悉的REST(Representational State Transfer)就是服务之间互相协作常用的轻量级通信机制之一。
  对于传统我们所熟知的Java RMI或者.Net Remoting等，虽然这类协议能够使用RPC的方式简化客户端的调用，使其像调用
本地接口一样调用远端的接口，但其最大的劣势在于，这类协议和语言、平台有非常强的耦合性，灵活性和扩展性较差。譬如说，如果使用了RMI作为通信协议，就意味着我们必须采用运行在JVM之上的语言才能完成互相协作。</p>

<p>  对于微服务而言，通过使用语言无关、平台无关的轻量级通信机制，使服务与服务之间的协作变得更加简单、标准化。同时，服
务内部则可以选择任何语言、工具或者平台。</p>

<h4>松耦合，独立部署</h4>

<p>  在传统的单块架构应用里，由于所有的功能都存在同一个代码库里。因此，当修改了该代码库的某个功能，在后续的测试过程中
都需要做回归测试，才能保证当前功能的修改不会影响其他已经工作的功能。也就是说，功能和功能之间存在着强耦合关系。</p>

<p>  当测试完成后，通过持续集成或者其他机制，会构建新版本的部署包。这个大而全的部署包里，自然包括了应用的所有功能。当
将该部署包部署到生产环境或者类生产环境时，由于所有功能都运行在同一个进程中。因此，必须要停掉当前正在运行的进程，完成部署，然后再启动进程，相信这个部署的过程对大家都不陌生。</p>

<p><img src="/images/microservice-design-and-practice/chapter2/loose-decouple-tradition-800-600.png" /></p>

<p>  但是，如果当前应用程序里包含类似定时任务的功能，则要考虑什么时间窗口适合部署，是否需要先停掉原有的数据访问源，以
防止数据被读入应用程序内存，但未处理完而导致的数据不一致性。多年前，我曾经接触过一个JAVA项目，应用程序本身是个含有定时任务的系统，每隔5秒都会从数据库读入数据，然后将其转换成JMS的消息传给不同的内部组件。每次部署时候，我们都需要先关掉相关的消息队列，以防止数据被读入到应用，但还未被处理完，进程就被关闭而导致的数据不一致性。</p>

<p>  微服务架构中，每个服务都是一个独立的业务单元，服务和服务之间是松耦合的。当对某个服务进行改变时，对其他的服务并不
会产生影响。</p>

<p>  对于每个服务，最好能使用独立的代码库。这样的话，当我们对前服务的代码进行修改后，并不会影响其他服务。也就是说，从
代码库的层面，服务与服务是松耦合、高度解耦的。类似的，对于每个服务，都有独立的测试机制，因此，对当前服务代码的修改，也并不需要担心代码改动而导致的大范围的回归测试。因此，从测试的角度而言，服务和服务之间也是松耦合、高度解耦的。另外，由于构建包是独立的，部署流程也是独立的，服务的运行也是在不同的进程中。因此，从部署和运行的角度考虑，服务和服务之间同样是松耦合、高度解耦的。</p>

<p><img src="/images/microservice-design-and-practice/chapter2/loose-decouple-microservice-800-600.png" /></p>

<p> 因此，对于每个服务而言，与其他服务高度解耦，同时不需要改变其依赖，只改变当前服务本身，就可以完成部署。</p>

<hr />

<h3>总结</h3>

<p>综上所述，微服务架构将一个复杂应用拆分成多个服务，服务与服务间能够互相协作、相互配合，从而为终端用户提供业务价值。每个服务独立运行在不同的进程中，服务与服务之间通过轻量的通讯机制交互，并且每个服务可以通过自动化部署方式独立部署。</p>

<p>微服务强调的是一种独立测试、独立部署、独立运行的软件架构模式。微服务中的每个服务，都可以作为一个独立的业务单元进行测试、部署，而且每个服务都能独立运行在不同的进程中。这些微服务满足细粒度的业务需求，并使用自动化部署工具进行发布。同时，这些微服务可以使用不同的开发语言，不同框架，以及不同的数据存储技术，因此它是一种高度自治的、非集中式管理的、细粒度的服务单元。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构(一)]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-1-dan-kuai-ying-yong-jia-gou/"/>
    <updated>2015-03-16T22:07:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-1-dan-kuai-ying-yong-jia-gou</id>
    <content type="html"><![CDATA[<p>[请勿转载]</p>

<h1>单块架构系统以及其面临的挑战</h1>

<h3>概述</h3>

<p>多年来，我们一直在技术的浪潮中乘风破浪，扬帆奋进，寻找更优秀的方法来构建IT系统，也一直在积极的学习并观察先进的公司如何以不同的架构方式构建或者优化其IT系统，来积极应对市场的变化，迅速做出响应，从而为客户提供更多的价值。</p>

<p>微服务架构模式（Microservice Architect Pattern）是近两年在软件架构模式领域里出现的一个新名词。虽然其诞生的时间不长，但其在各种演讲、文章、书籍上所出现的频率已经让很多人意识到它对软件领域所带来的影响。那到底什么是微服务，当我们谈论微服务时，它代表着一种什么样的含义？微服务适合应用在什么场景下，以及它有什么样的优缺点？微服务和SOA到底有没有区别？在接下来的几部分里，我将为大家揭开微服务的神秘面纱。</p>

<!-- More -->


<p>不过，在我们开始探讨微服务架构之前，让我们先回顾一下三层应用架构的发展历程并认识一下什么是单块架构应用。</p>

<h3>三层应用架构的发展</h3>

<p>对于任何一个软件应用系统而言，其构建目标都是为了满足某类用户的需求，即为用户传递价值。一直以来，软件的架构设计是决定应用系统是否能够被正确、有效实现的关键要素之一。架构设计描述了在应用系统的内部，如何根据业务、技术、组织，以及灵活性、可扩展性、可维护性等多种因素，将应用系统划分成不同的部分，并使这些部分彼此之间相互分工、相互协作，从而为用户提供某种特定价值的方式。</p>

<h4>应用的三层架构</h4>

<p>   现实生活中，“层”这个字的含义，对大家一点都不陌生。我们经常说楼房高多少层，蛋糕有几层等。通常来说，层有好几种定义，但其中最耳
熟能详的，莫过于“层”能帮助我们划分出构成某整体事物的，上下相互支撑的的不同部分。譬如说，我们喜欢吃的蛋糕，一般是由三层组成：第一层的蛋糕体、第二层的奶油，和第三层的水果。从顶部至底部，每一层依赖于下一层，从底部到顶部，每一层又支撑着上一层。</p>

<p>   在软件架构模式的领域，经过多年的发展，也有了层的概念：</p>

<ul>
<li> 层能够被单独构造；</li>
<li> 层具有区别于其他层的显著特点；</li>
<li> 层与层之间能够互相连接、互相支撑、互相作用，相互协作构成一个整体。</li>
<li> 层的内部，可以被替换成其他可工作的部分，但对整体的影响不大。</li>
</ul>


<p>   以WEB应用程序为例，在WEB应用程序开发的早期，由于受到面向过程的思维及设计方式的影响，所有的逻辑代码并没有明显的区分，因此代码
之间的调用相互交错，错综复杂。譬如，我们早期使用的ASP、JSP以及PHP，都是将所有的页面逻辑、业务逻辑以及数据库访问逻辑放在一起，这是我们通常提到的一层架构。</p>

<p><img src="/images/microservice-design-and-practice/chapter1/1-layer-800-600.png" /></p>

<p>   随着JAVA，.NET等高级语言的快速发展，这些语言为开发者提供了越来越方便的的数据访问机制，如Java语言的JDBC、IO流，或者.NET的ADO.NET等。这时候，数据访问部分的代码逐渐有了清晰的结构，但表示逻辑和业务逻辑依然交织在一起，我们称这个阶段为二层架构阶段。</p>

<p><img src="/images/microservice-design-and-practice/chapter1/2-layer-800-600.png" /></p>

<p>   随着面向对象分析、面向对象设计、面向对象原则、设计模式、企业架构模式等理念以及方法论的不断发展，从为用户提供功能、以及有效组织软件结构的角度考虑，WEB
应用中不同职责的部分逐渐被定义在了不同的层次，每一层负责的部分更趋向于具体化，细致化，于是软件的三层架构逐渐出现了。三层架构通常包括表示层、业务逻辑层以及数据访问层。</p>

<p><img src="/images/microservice-design-and-practice/chapter1/3-layer-800-600.png" /></p>

<ul>
<li> 表示层</li>
</ul>


<p>   表示层部分通常指当用户使用应用程序时，看见的、听见的、输入的或者交互的部分。譬如，有可能是信息的显示，音乐的的播放或者可以输
入的文本框，单选按钮以及可点击的按钮等。通过这些元素，用户同软件进行交互并获取期望的价值。目前的用户接口大部分情况下为WEB方式，当然也可以是桌面软件的形式，例如. NET的WINFORM或者Java的SWING。</p>

<ul>
<li> 业务逻辑层</li>
</ul>


<p>   业务逻辑部分是根据用户输入的信息，进行逻辑计算或者业务处理的部分。业务逻辑层则主要聚焦应用程序对业务问题的逻辑处理，以及业务
流程的操作，它是大部分软件系统区别与其他系统的核心。譬如，当用户点击一个按钮后，它可能会触发业务逻辑部分的代码进行运算，生成用户期望的结果。举例来说，在一个电子商务平台中，作为用户，当我们下单购买某个商品后，应用程序的业务逻辑层会对订单如何进行处理，如何计算折扣、如何配送等进行处理。</p>

<ul>
<li> 数据访问层</li>
</ul>


<p>  在用户同应用程序交互的过程中，会产生数据。这类数据需要通过某种机制被有效的保存，并在将来能够被重复使用，或者提供给其他系统。这
种机制或者方法就是数据访问层最关注的部分。也就是说，它关注的是应用程序是如何有效的将数据存储到数据库、文件系统或者其他存储介质中。有一点要注意的是，它关心的是对原始数据的操作（数据库或者文本文件等存放数据的形式），而非原始数据的存储介质本身。譬如，在一个电子商务平台中，商品的信息是如何存储，图片的信息是如何获取的等。</p>

<p>   三层架构的出现，一方面是为了解决应用程序中代码间调用复杂、代码职责不清的问题。其通过在各层间定义接口，并将接
口与实现分离，可以很容易的用不同的实现来替换原有层次的实现，从而有效降低层与层之间的依赖。这种方式不仅有利于帮助团队理解整个应用架构，降低后期维护成本，同时也有利于制定整个应用程序架构的标准。</p>

<p>   另一方面，三层结构的出现从某种程度上也解决了企业内部如何有效的根据技能调配人员，提高生产效率的问题。在大环境
下，有效的分层能使不同职责的人员各司其职，更聚焦与个人专业技能的发展和培养。三层结构的出现不仅标准化了复杂系统的逻辑划分，更帮助企业解决了如何有效形成技术人员组织结构的问题，因此在很长的一段时间里，它一直是软件架构的经典模式之一。</p>

<h4>非三层架构</h4>

<p>有些人认为，对于一个WEB应用程序，其被自动地分成了三层架构，因为它有三个分离的部件，如图所示：</p>

<p><img src="/images/microservice-design-and-practice/chapter1/not-3-layer-800-600.png" /></p>

<p>   这三个部分看起来虽然满足“层”的概念，但它并不是我们所说的软件架构的层。就像我们所说的奶油蛋糕，我们可以在蛋糕
的底部加上稳固的底座，在蛋糕的外部加上漂亮的包装盒，但仔细想想，底座可以用不同品牌的底座，可以用纸质材料的，也可以用树脂材料的；包装盒可以用红色的一次性纸袋，也可以用蓝色的带着花纹的铁盒，它们并不是我们蛋糕组成的必须一部分。</p>

<p>   浏览器可以独立存在与WEB应用程序之外，WEB应用程序也可以被不同的浏览器访问，因此浏览器不是WEB应用程序的部分
。虽然最近几年，在浏览器端，我们可以使用很多JavaScript库或者框架独立开发前端应用，但它的范畴超出了我们目前讨论的三层架构，更多的属于富客户端以及前后端分离的应用。</p>

<p>   类似的，数据库服务器也可以独立存在于应用程序之外，因此它也不是应用程序的一部分。虽然有些应用程序的逻辑代码，
被设计成必须是在数据库中运行，例如存储过程或者触发器，但这种用法并不推荐，原因是将业务逻辑放在了数据库本身，大大增加了后期维护的复杂度和数据迁移的成本。</p>

<h3>单块架构应用</h3>

<h4>什么是单块架构应用</h4>

<p>   虽然软件的三层架构帮助我们将应用在逻辑上分成了三层，但它并不是物理上的分层。这也就意味着，即便我们将应用架构分成了 所谓的三层
，经过开发团队对不同层的代码实现，经历过编译（如果非静态语言，可以跳过编译阶段）、打包、部署后，不考虑负载均衡以及水平扩展的情况，最终还是运行在同一个机器的同一个进程中。
对于这种功能集中、代码和数据中心化、一个发布包、部署后运行在同一进程的应用程序，我们通常称之为单块架构应用。典型的单块架构应用，莫过于传统的J2EE项目所构建的产品或者项目，它们存在的形态一般是WAR包或者EAR包。当部署这类应用时，通常是将整个一块都作为一个整体，部署在同一个WEB容器，如Tomcat或者Jetty中。当这类应用运行起来后，所有的功能也都运行在同一个进程中。</p>

<p>   类似的，基于Ruby On Rails的单块架构应用，一般逻辑上分为控制器层、模型层以及视图层，同时代码存放在遵循一定层级结构 的目录中
。当部署这类应用的时候，通常是使用SSH或者其他一些工具，如<a href="https://github.com/capistrano/capistrano">Capistrano</a>将整个目录部署在<a href="https://www.phusionpassenger.com/">Passenger</a>或者其他WEB容器中。当这类应用运行起来后，所有的功能也都运行在同一个进程中。</p>

<p><img src="/images/microservice-design-and-practice/chapter1/in-a-web-container-800-600.png" /></p>

<p>因此，对于单块架构应用的定义，其实是基于分层软件架构设计的系统基础之上，从部署模式、运行模式角度去考虑的一种定义方式。</p>

<h4>单块架构应用的优势</h4>

<ul>
<li> 易于开发</li>
</ul>


<p>   对单块架构的应用程序而言，开发方式相对较简单。首先从概念上，现有的大部分工具、应用服务器、框架都是这类单块架构应用程序，容易
理解而且为人所熟知。如果从实践角度出发，现有的集成开发工具比较适合单块架构的应用程序，像NetBeans、Eclipse、IDEA等，它们都能够有效加载并配置整个应用程序的依赖，方便开发人员开发、运行、调试等。</p>

<ul>
<li> 易于测试</li>
</ul>


<p>   单块架构应用程序也非常容易被测试，因为所有的功能都运行在一个进程中，启动集成开发环境或者将发布包部署到某一环境，一旦启动该进程，就可以立即开始系统测试或者功能测试。</p>

<ul>
<li> 易于部署</li>
</ul>


<p>   对单块架构的应用程序而言，部署也比较容易。实际上，由于所有的功能最终都会打成一个包，因此只需复制该软件包到服务器相应的位置即
可。当然，部署的方式可以有很多种，最简单的可以使用SCP远程拷贝到指定的目录下，当然也可以使用某些自动化的工具来完成。</p>

<ul>
<li> 易于水平伸缩</li>
</ul>


<p>   对单块架构的应用程序而言，水平伸缩也比较容易。实际上，由于所有的功能最终都会打成一个包，且只能运行在一个进程中，因此单块架构
的水平伸缩，更确切的理解其实是克隆，即新建一个服务器节点，配置好该节点的运行环境，复制软件包到相应的位置，运行改应用程序。当然，必须要确保负载均衡器能采取某种分发策略，有效的将请求分发到新创建的节点。</p>

<h4>单块架构面临的挑战</h4>

<p>   随着最近几年互联网行业的迅猛发展，随着公司或者组织业务的不断扩张，需求不断的增加以及用户量的不断增加，单块架构的优势已逐渐无法
适应互联网时代的快速变化，面临着越来越多的挑战。譬如说，一方面，随着业务的扩大，如何为用户提供可靠的服务，如何有效处理用户增多后导致并发请求数增多，导致的响应慢的问题，以及如何有效解决用户增多后带来的大数据量的问题等。另外一方面，随着公司或者组织业务的不断扩张，需求不断的增加，越来越多的人加入开发团队，代码库也在急剧膨胀。在这种情况下，单块架构的可维护性、灵活性在降低，而测试成本、构建成本以及维护成本却在显著增加。</p>

<p><img src="/images/microservice-design-and-practice/chapter1/advantages-vs-disadvantages-800-600.png" /></p>

<h5>1.维护成本增加</h5>

<p>   随着应用程序的功能越来越多，团队越来越大，相应的沟通成本、管理成本、人员协调成本必然会显著增加。譬如说，对于使
用Java编写的中型应用而言，当代码量为几万行时，可能只需要几人左右的团队维护。当代码量上升到几十万行级别时，可能需要几十人甚至是上百人的团队。</p>

<p>   另外，随着应用程序功能的增多，当出现缺陷时，有可能引起缺陷的原因组合就会比较多，这也会导致分析缺陷、定位缺陷、修复缺陷的成本相应增高，也就意味着缺陷的平均修复周期可能会花费更长时间。</p>

<p>   另外，随着代码量的增大，在开发人员对全局功能缺乏深度理解的情况下，修复一个缺陷，还有可能引入其他的缺陷，在自动
化测试机制不完善的情况下，很可能导致该过程陷入“修复越多，缺陷越多”的恶性循环。</p>

<p><img src="/images/microservice-design-and-practice/chapter1/complexity-increase-as-feauture-growing-800-600.png" /></p>

<h5>2.持续交付周期长</h5>

<p>   随着应用程序的功能越来越多，代码越来越复杂，构建和部署时间也会相应的增长。在现有部署流水线稳定工作的情况下，对
单块架构应用程序做任何细微的修改以及代码提交，都会触发部署流水线，对整个应用程序进行代码编译、运行单元测试、代码检查、构建并生成部署包、验证功能等，这也就意味着流水线的反馈周期变长，单位时间内构建的效率变低了。</p>

<p>   另一方面，团队人员的增多，部署流水线运行的时间增加，开发人员能够提交代码的时间窗口就相应减少，（因为流水线运行
的过程中，是禁止提交代码的），可能出现长时间等待代码提交，却无法提交的情况，极大破坏了团队的灵活性并降低了团队工作效率。几年前，我曾经工作在一个50万代码行的单块架构应用上，整个应用由一个50人左右的分布式团队负责。通常情况下，从开发人员提交代码到运行单元测试、构建发布包、运行功能测试、标记为可发布状态大概需要40分钟，时间稍微有点长，但团还能忍受。关键的问题是开发人员通常都是集中在下午3点左右，完成一定功能的情况下提交代码，结果就导致3点至5点那个时间段，成了代码提交的瓶颈，极大影响了该应用的持续集成和构建的效率。</p>

<h5>3.新人培养周期长</h5>

<p>   随着应用程序的功能越来越多，代码变得越来越复杂的同时，对于新加入团队的成员而言，了解行业背景、熟悉应用程序业
务、配置本地开发环境，这些看似简单的任务，将会花费更长的时间。我曾经有个朋友，在加入一家世界500强的知名IT公司后，被安排到了一个百万级代码的产品组里。他花了将近1个月的时间来熟悉产品文档、配置开发环境后，才在本地成功的运行起了这个应用。在他从事这份新工作的头一个月里，我们好几次聊到他的新工作，得到的答案都是一样，“看文档，装环境”。对个人而言，花一个月时间来配置本地开发环境，其中的滋味和感受大家可想而知，我估计人世间比这更痛苦的事情也没几件了。而对公司或者部门而言，本期望员工花费数天就能配置好的环境，却花了一个月才能完成，这更是极大的浪费。更有甚者，在第一次配置完开发环境后，好几年都不愿意再升级或者重装系统，真是一招被蛇咬，十年怕井绳。</p>

<p><img src="/images/microservice-design-and-practice/chapter1/new-employee-chanlleges-800-600.png" /></p>

<h5>4.技术选型成本高</h5>

<p>   传统的单块架构系统倾向采用统一的技术平台或方案来解决所有问题。通常，技术栈的决策是在团队开发之前经过架构师、技术经理慎重评估后选定的，每个团队成员都必须使用相同的开发语言、持久化存储及消息系统，而且要使用类似的工具。随着应用程序的复杂性逐渐增加以及功能越来越多，如果团队希望尝试引入新的框架、技术，或者对现有技术栈升级，通常会面临不小的风险。</p>

<p>   另一方面，互联网行业不仅市场变化快，而且技术变化也快。譬如，短短几年几年时间，光前端JavaScript的框架，就出现了好几十个，从早一点的<a href="http://backbonejs.org/">Backbone</a>、<a href="http://emberjs.com">Ember</a>到<a href="https://angularjs.org">AngularJS</a>、<a href="http://www.ractivejs.org/">Ractive</a>等等。类似的，后端的框架、工具等也是层出不穷，有兴趣的朋友可以参考下<a href="http://www.thoughtworks.com/radar">ThoughtWorks的技术雷达</a>(该技术雷达是ThoughtWorks对业界技术、工具、语言等发展趋势的分析以及预测报告)。因此，对单块架构的应用而言，初始的技术选型严重限制了其将来采用不同语言或框架的能力。如果想尝试新的编程语言或者框架，没有完备的功能测试集，很难平滑的完成替换，而且系统规模越大，风险越高。</p>

<h5>5.可伸缩性差</h5>

<p>  如果应用程序的所有功能代码都运行在同一个服务器上，将会导致应用程序的扩展非常困难。如果迫切的需要扩展，那么垂直扩展可能是最容
易的（钱不是问题）。在大多数情况下，如果舍得砸钱上IBM的服务器、Oracle的数据库或者来自EMC的存储设备，不用改变一行代码，整个世界都变好了。不幸的是，伴随着业务的增长，数据的增长，垂直扩展会变得越来越吃力，成本越来越高。这也是为什么在业很多公司开始尝试使用开源，放弃这些昂贵的IOE产品的原因。这下明白为什么近几年去IOE的呼声越来越高了吧。</p>

<p>  当考虑水平扩展时，通常的做法是建立一个集群，通过在集群中不断的添加新节点，然后借助前端的负载均衡器，将用户的
请求按照某种算法，譬如轮转法、散列法或者最小连接法等合理的将请求分配到不同的节点上。但是，由于所有程序代码都运行在服务器上的同一个进程中，会导致应用程序的水平扩展成本非常高。譬如说，如果应用程序某部分的功能是内存密集型的，如需要缓存大量数据，而另外一部分功能是CPU密集型的，如需要进行大量的运算，那么每次实施水平扩展，运行该应用的服务器都必须有足够的内存和强劲的CPU来满足需求。因此，鉴于每个服务器都要提供该应用系统所需要的各种资源，基础设施的整体花费可能会非常高。当然，如果某些节点保持状态，如用户登陆后的会话信息等，更增加了水平扩展的难度。</p>

<h5>6.构建全功能团队难</h5>

<p>   最后，非常微妙的是，随着应用程序的功能越来越多，代码变得越来越复杂，其应用程序的复杂结构也会逐渐映射到研发团队的
结构上。康威定律指出：一个组织的设计成果，其结构往往对应于这个组织中的沟通结构。单块架构的开发模式在分工时往往以技能为单位，比如UX团队、服务端团队和数据库团队，这样的分工可能会导致任何功能上的改变都需要跨团队沟通和协调。譬如说，用户体验工程师（UX）更专注负责用户接口部分，业务层开发者则负责建立服务器后端的业务逻辑，数据库工程师和DBA们更关注数据访问组件和数据库。鉴于这些问题，随着时间的推移，不仅代码越来越难以管理，其对团队结构的影响也越来越明显。</p>

<p><img src="/images/microservice-design-and-practice/chapter1/build-team-aroud-business-800-600.png" /></p>

<p>综上所述，随着业务的不断扩大，需求功能的持续增加，单块架构已经很难满足业务快速变化的需要。一方面，代码的可维护性、扩展性、灵活性在降低；而另一方面，系统的测试成本、构建成本以及维护成本却在显著增加。因此，随着项目或者产品规模的不断扩大，单块架构应用的改造与重构势在必行。</p>

<hr />

<h3>总结</h3>

<p>   互联网时代的产品通常有几类特点：创新成本低、需求变化快，用户群体庞大，它和几年前我们熟悉的单块
架构应用有着本质的不同。随着市场变化快、用户需求变化快、用户访问量增加的同时，单块架构应用的维护成本、人员的培养成本、缺陷修复成本、技术架构演进的成本、系统扩展成本等都在增加，因此单块架构曾经的优势已逐渐无法适应互联网时代的快速变化，面临着越来越多的挑战。</p>
]]></content>
  </entry>
  
</feed>
